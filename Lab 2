___________________________________ 2 ЛАБОРАТОРНА ______________________________
___________________________________ 1 завдання ______________________________
#include <iostream>                                 // Підключення бібліотеки для роботи з введенням і виведенням
using namespace std;                                // Щоб не писати std:: перед стандартними елементами

int main() {
    long long a, b, c, d;                           // Оголошення змінних типу long long (для великих чисел)
    cout << "Введіть a, b, c, d: ";                 // Вивід повідомлення для користувача

    if (!(cin >> a >> b >> c >> d)) return 0;       // Зчитування значень і перевірка правильності введення

    // 12 * a = (a << 3) + (a << 2) → зсув вліво на 3 (8a) + на 2 (4a)
    long long a12 = (a << 3) + (a << 2);

    // 15 * d = (d << 4) - d → 16*d - d
    long long d15 = (d << 4) - d;

    // 12 * b = (b << 3) + (b << 2) → аналогічно як з a
    long long b12 = (b << 3) + (b << 2);

    // Чисельник дробу: 15*d + 12*b
    long long numerator = d15 + b12;

    // Ділення на 1024 = зсув вправо на 10 (2^10 = 1024)
    long long frac = numerator >> 10;

    // 12 * c = (c << 3) + (c << 2)
    long long c12 = (c << 3) + (c << 2);

    // Підсумкова формула:
    // Результат = 12*a + (15*d + 12*b)/1024 - 12*c + 15*d
    long long result = a12 + frac - c12 + d15;

    cout << "Результат: " << result << endl;       // Виведення результату
    return 0;                                      // Завершення програми
}

___________________________________ 2 завдання ______________________________
#include <iostream>        // Підключення бібліотеки для роботи з консольним введенням/виведенням
#include <fstream>         // Для роботи з файлами (читання та запис)
#include <vector>          // Підключення контейнера vector
#include <string>          // Для роботи з рядками
#include <iomanip>         // Для форматування виводу (hex, setw, setfill)

using namespace std;       // Використання стандартного простору імен, щоб не писати std::

/*
Функція обчислення біта парності (використовується XOR логікою):
- Рахує кількість встановлених (1) бітів у перших 15 бітах.
- Якщо кількість непарна → повертає 1 (біт парності).
- Якщо парна → повертає 0.
*/
unsigned char parbit(unsigned short value) {
int count = 0;                    // Лічильник одиничних бітів
for (int i = 0; i < 15; ++i) {    // Перебір перших 15 бітів
if (value & (1 << i)) count++; // Перевірка, чи встановлений біт
}
return count % 2;                 // Повернення біта парності (1 або 0)
}

int main() {
vector<string> lines(4);          // Вектор для збереження 4 рядків введеного тексту

cout << "Введіть 4 рядки тексту (до 32 символів кожен):" << endl; // Запит до користувача
for (int i = 0; i < 4; ++i) {     // Цикл по 4 рядках
getline(cin, lines[i]);       // Зчитування рядка повністю
while (lines[i].length() < 32) lines[i] += ' '; // Доповнення пробілами до 32 символів
}

ofstream out("encrypted.bin", ios::binary); // Відкриття файлу для запису у двійковому режимі
if (!out) {                                  // Перевірка успішності відкриття
cerr << "Не вдалося створити файл!" << endl;
return 1;                                // Завершення програми при помилці
}

cout << "\nШифрування:" << endl;             // Повідомлення про початок шифрування
for (int row = 0; row < 4; ++row) {          // Перебір рядків
for (int pos = 0; pos < 32; ++pos) {     // Перебір символів у кожному рядку
unsigned char ch = lines[row][pos];  // Витягуємо символ
unsigned short value = 0;            // Створюємо 16-бітне число для кодування

value |= (pos & 0x1F);               // Біти 0–4: позиція символу (0–31)
value |= ((row & 0x03) << 5);        // Біти 5–6: номер рядка (0–3)
value |= ((ch & 0xFF) << 7);         // Біти 7–14: ASCII код символу
value |= (parbit(value) << 15);      // Біт 15: біт парності

out.write(reinterpret_cast<char*>(&value), sizeof(value)); // Запис значення у файл

cout << hex << setw(4) << setfill('0') << value << " "; // Вивід числа в hex форматі
}
cout << endl;                            // Перехід на новий рядок після 32х значень
}

out.close();                                 // Закриття файлу
cout << "\nШифрування завершено. Дані записано у encrypted.bin" << endl;

ifstream in("encrypted.bin", ios::binary);   // Відкриття файлу для читання
if (!in) {                                   // Перевірка на помилку відкриття
cerr << "Не вдалося відкрити файл для розшифрування!" << endl;
return 1;                                // Завершення програми при помилці
}

vector<string> decrypted(4, string(32, ' ')); // Підготовка вектора рядків для дешифрації
unsigned short value;                         // Змінна для читання 16-бітних даних

for (int row = 0; row < 4; ++row) {           // Перебір рядків
for (int pos = 0; pos < 32; ++pos) {      // Перебір позицій
if (!in.read(reinterpret_cast<char*>(&value), sizeof(value))) { // Читаємо з файлу
cerr << "Помилка читання файлу!" << endl;
return 1;                         // Завершення програми при помилці
}

char ch = (value >> 7) & 0xFF;        // Отримуємо ASCII символ (біти 7–14)
int r_index = (value >> 5) & 0x03;    // Витягуємо номер рядка
int p_index = value & 0x1F;           // Витягуємо позицію символу
decrypted[r_index][p_index] = ch;     // Встановлюємо символ у правильне місце
}
}
in.close();                                   // Закриваємо файл

cout << "\nРозшифрований текст:" << endl;     // Виведення результату
for (const auto& line : decrypted) {          // Перебір дешифрованих рядків
cout << line << endl;                     // Вивід кожного рядка
}

return 0;                                     // Завершення програми
}

___________________________________ 3 завдання ______________________________
#include <iostream>        // Підключення бібліотеки для роботи з консольним введенням/виведенням
#include <fstream>         // Для роботи з файлами (читання та запис)
#include <vector>          // Підключення контейнера vector
#include <string>          // Для роботи з рядками
#include <iomanip>         // Для форматування виводу (hex, setw, setfill)

using namespace std;       // Використання стандартного простору імен, щоб не писати std::

/*
 Функція обчислення біта парності (використовується XOR логікою):
 - Рахує кількість встановлених (1) бітів у перших 15 бітах.
 - Якщо кількість непарна → повертає 1 (біт парності).
 - Якщо парна → повертає 0.
*/
unsigned char parbit(unsigned short value) {
    int count = 0;                    // Лічильник одиничних бітів
    for (int i = 0; i < 15; ++i) {    // Перебір перших 15 бітів
        if (value & (1 << i)) count++; // Перевірка, чи встановлений біт
    }
    return count % 2;                 // Повернення біта парності (1 або 0)
}

int main() {
    vector<string> lines(4);          // Вектор для збереження 4 рядків введеного тексту

    cout << "Введіть 4 рядки тексту (до 32 символів кожен):" << endl; // Запит до користувача
    for (int i = 0; i < 4; ++i) {     // Цикл по 4 рядках
        getline(cin, lines[i]);       // Зчитування рядка повністю
        while (lines[i].length() < 32) lines[i] += ' '; // Доповнення пробілами до 32 символів
    }

    ofstream out("encrypted.bin", ios::binary); // Відкриття файлу для запису у двійковому режимі
    if (!out) {                                  // Перевірка успішності відкриття
        cerr << "Не вдалося створити файл!" << endl;
        return 1;                                // Завершення програми при помилці
    }

    cout << "\nШифрування:" << endl;             // Повідомлення про початок шифрування
    for (int row = 0; row < 4; ++row) {          // Перебір рядків
        for (int pos = 0; pos < 32; ++pos) {     // Перебір символів у кожному рядку
            unsigned char ch = lines[row][pos];  // Витягуємо символ
            unsigned short value = 0;            // Створюємо 16-бітне число для кодування

            value |= (pos & 0x1F);               // Біти 0–4: позиція символу (0–31)
            value |= ((row & 0x03) << 5);        // Біти 5–6: номер рядка (0–3)
            value |= ((ch & 0xFF) << 7);         // Біти 7–14: ASCII код символу
            value |= (parbit(value) << 15);      // Біт 15: біт парності

            out.write(reinterpret_cast<char*>(&value), sizeof(value)); // Запис значення у файл

            cout << hex << setw(4) << setfill('0') << value << " "; // Вивід числа в hex форматі
        }
        cout << endl;                            // Перехід на новий рядок після 32х значень
    }

    out.close();                                 // Закриття файлу
    cout << "\nШифрування завершено. Дані записано у encrypted.bin" << endl;

    ifstream in("encrypted.bin", ios::binary);   // Відкриття файлу для читання
    if (!in) {                                   // Перевірка на помилку відкриття
        cerr << "Не вдалося відкрити файл для розшифрування!" << endl;
        return 1;                                // Завершення програми при помилці
    }

    vector<string> decrypted(4, string(32, ' ')); // Підготовка вектора рядків для дешифрації
    unsigned short value;                         // Змінна для читання 16-бітних даних

    for (int row = 0; row < 4; ++row) {           // Перебір рядків
        for (int pos = 0; pos < 32; ++pos) {      // Перебір позицій
            if (!in.read(reinterpret_cast<char*>(&value), sizeof(value))) { // Читаємо з файлу
                cerr << "Помилка читання файлу!" << endl;
                return 1;                         // Завершення програми при помилці
            }

            char ch = (value >> 7) & 0xFF;        // Отримуємо ASCII символ (біти 7–14)
            int r_index = (value >> 5) & 0x03;    // Витягуємо номер рядка
            int p_index = value & 0x1F;           // Витягуємо позицію символу
            decrypted[r_index][p_index] = ch;     // Встановлюємо символ у правильне місце
        }
    }
    in.close();                                   // Закриваємо файл

    cout << "\nРозшифрований текст:" << endl;     // Виведення результату
    for (const auto& line : decrypted) {          // Перебір дешифрованих рядків
        cout << line << endl;                     // Вивід кожного рядка
    }

    return 0;                                     // Завершення програми
}

___________________________________ 4 завдання ______________________________
#include <iostream>                // Підключення бібліотеки для роботи з введенням/виведенням
#include <vector>                  // Підключення бібліотеки для використання std::vector
using namespace std;              // Щоб не писати std:: перед стандартними об'єктами

/*
Функція parbits — рахує кількість одиниць у бітових позиціях:
- word → 16-бітне слово
- odd → якщо true → перевіряються непарні біти (1,3,5...)
якщо false → парні біти (0,2,4...)
- Повертає 1, якщо кількість одиниць непарна; 0 — якщо парна
*/
int parbits(unsigned short word, bool odd) {
int sum = 0;                                        // Лічильник одиничних бітів
for (int i = 0; i < 14; i++) {                      // Перевіряємо тільки перші 14 бітів (0–13)
if (odd && (i % 2 == 0)) continue;              // Якщо шукаємо непарні (odd=true), пропускаємо парні біти
if (!odd && (i % 2 == 1)) continue;             // Якщо шукаємо парні (odd=false), пропускаємо непарні біти
if (word & (1 << i)) sum++;                     // Якщо біт = 1, збільшуємо лічильник
}
return sum % 2;                                     // Повертаємо 1 (непарна кількість), або 0 (парна)
}

int main() {
int n;                                              // Змінна для кількості слів
cout << "Введіть кількість слів: ";                 // Запит користувачу
cin >> n;                                           // Зчитування кількості слів

vector<unsigned short> words(n);                    // Вектор для збереження 16-бітних слів
cout << "Введіть слова у форматі 0-65535:\n";       // Інструкція користувачу
for (int i = 0; i < n; i++) {                       // Цикл введення слів
cin >> words[i];                                // Зберігаємо введене слово
}

// Перевірка CRC для кожного слова
for (int i = 0; i < n; i++) {
unsigned short w = words[i];                    // Поточне слово
int crcodd = parbits(w, true);                  // Обчислення біта парності непарних бітів
int crceven = parbits(w, false);                // Обчислення біта парності парних бітів

int bit14 = (w >> 14) & 1;                      // Витягування біта на позиції 14 (15-й біт)
int bit15 = (w >> 15) & 1;                      // Витягування біта на позиції 15 (16-й біт)

cout << "Слово " << i + 1 << ": ";              // Вивід номера слова
if (bit14 == crcodd && bit15 == crceven) {      // Порівняння отриманих CRC зі збереженими
cout << "CRC вірна \n";                     // Якщо співпадає — все добре
} else {
cout << "CRC помилкова \n";                 // Якщо ні — виявлено помилку
}
}

return 0;                                           // Завершення програми
}
